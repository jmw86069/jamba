% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamba-string.r
\name{provigrep}
\alias{provigrep}
\title{provigrep: progressive case-insensitive value-grep}
\usage{
provigrep(patterns, x, maxValues = NULL, sortFunc = c, rev = FALSE,
  returnType = c("vector", "list"), ignore.case = TRUE, value = TRUE,
  ...)
}
\arguments{
\item{patterns}{vector of grep patterns}

\item{x}{vector to be tested by \code{\link[base]{grep}}}

\item{maxValues}{integer or NULL, the maximum matching entries to
return per grep pattern. This parameter is mainly useful when returning
a list of matches, where one would like each list to contain a maximum
number of entries.}

\item{sortFunc}{function or NULL, used to sort entries within each set of
matching entries. Use NULL to avoid sorting entries.}

\item{rev}{logical whether to reverse the order of matching entries. Use
TRUE if you would like entries matching the patterns to be placed last,
and entries not matching the grep patterns to be placed first. This
technique is effective at placing "noise named" at the end of a long
vector, for example.}

\item{returnType}{character indicating whether to return a vector or list.
A list will be in order of the grep patterns, using empty elements to
indicate when no entries matched each pattern. This output is useful
when you would like to know which patterns matched specific entries.}

\item{ignore.case}{logical parameter sent to \code{\link[base]{grep}}, TRUE
runs in case-insensitive mode, as by default.}

\item{value}{logical indicating whether to return the matched value,
or when \code{value=FALSE} the index position is returned.}

\item{...}{additional arguments are passed to \code{vigrep()}.}
}
\description{
case-insensitive value-grep for a vector of patterns
}
\details{
Purpose is to provide "progressive vigrep()",which is value-returning,
case-insensitive grep, starting with an ordered vector of grep patterns.
For example, it returns entries in the order they are matched, by the
progressive use of grep patterns.

It is particularly good when using multiple grep patterns, since
\code{grep()} does not accept multiple patterns as input. This function
also only returns the unique matches in the order they were matched,
which alleviates the need to run a series of \code{grep()} functions
and collating their results.

It is mainly to allow for prioritized ordering of matching entries, where
one would like certain matching  entries first, followed by another
set of matching entries, without duplication. For example,
one might grep for a few patterns, but want certain pattern hits to be
listed first.
}
\examples{
# a rather comical example
# set up a test set with labels containing several substrings
set.seed(1);
testTerms <- c("robot","tree","dog","mailbox","pizza","noob");
testWords <- pasteByRow(t(combn(testTerms,3)));

# now pull out entries matching substrings in order
provigrep(c("pizza", "dog", "noob", "."), testWords);
# more detail about the sort order is shown with returnType="list"
provigrep(c("pizza", "dog", "noob", "."), testWords, returnType="list");
# rev=TRUE will reverse the order of the list
provigrep(c("pizza", "dog", "noob", "."), testWords, returnType="list", rev=TRUE);
provigrep(c("pizza", "dog", "noob", "."), testWords, rev=TRUE);

# another example showing ordering of duplicated entries
set.seed(1);
x <- paste0(
   sample(letters[c(1,2,2,3,3,3,4,4,4,4)]),
   sample(1:5));
x;
# sort by letter
provigrep(letters[1:4], x)

# show more detail about how the sort is performed
provigrep(letters[1:4], x, returnType="list")

# rev=TRUE will reverse the order of pattern matching
# which is most useful when "." is the last pattern:
provigrep(c(letters[1:3], "."), x, returnType="list")
provigrep(c(letters[1:3], "."), x, returnType="list", rev=TRUE)

}
\seealso{
Other jam grep functions: \code{\link{grepls}},
  \code{\link{igrepHas}}, \code{\link{igrep}},
  \code{\link{unigrep}}, \code{\link{unvigrep}},
  \code{\link{vgrep}}, \code{\link{vigrep}}
}
\concept{jam grep functions}
