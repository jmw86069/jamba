% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamba-string.r
\name{mixedSorts}
\alias{mixedSorts}
\title{sort alphanumeric values within a list format}
\usage{
mixedSorts(
  x,
  blanksFirst = TRUE,
  na.last = NAlast,
  keepNegative = FALSE,
  keepInfinite = TRUE,
  keepDecimal = FALSE,
  ignore.case = TRUE,
  sortByName = FALSE,
  na.rm = FALSE,
  verbose = FALSE,
  NAlast = TRUE,
  debug = FALSE,
  ...
)
}
\arguments{
\item{x}{input vector}

\item{blanksFirst}{logical whether to order blank entries before entries
containing a value.}

\item{na.last}{\code{logical} indicating whether to move NA entries at
the end of the sort.}

\item{keepNegative}{logical whether to keep '-' associated with adjacent
numeric values, in order to sort them as negative values.}

\item{keepInfinite}{logical whether to allow "Inf" to be considered
a numeric infinite value.}

\item{keepDecimal}{logical whether to keep the decimal in numbers,
sorting as a true number and not as a version number. By default
keepDecimal=FALSE, which means "v1.200" should be ordered before
"v1.30". When keepDecimal=TRUE, the numeric sort considers only
"1.2" and "1.3" and sorts in that order.}

\item{ignore.case}{logical whether to ignore uppercase and lowercase
characters when defining the sort order.}

\item{sortByName}{logical whether to sort the vector x by names(x) instead
of sorting by x itself.}

\item{verbose}{logical whether to print verbose output.}

\item{NAlast}{\code{logical} deprecated in favor of argument \code{na.last}
for consistency with \code{base::sort()}.}

\item{...}{additional parameters are sent to \code{\link{mixedOrder}}.}
}
\description{
sort alphanumeric values within a list format
}
\details{
This function is an extension to \code{mixedSort()} to sort each vector
in a list. It applies the sort to the whole unlisted vector then
splits back into list form.

In the event the input is a nested list of lists, only the first
level of list structure is maintained in the output data. For
more information, see \code{rlengths()} which calculates the recursive
nested list sizes.
}
\examples{
# set up an example list of mixed alpha-numeric strings
set.seed(12);
x <- paste0(sample(letters, replace=TRUE, 52), rep(1:30, length.out=52));
x;
# split into a list as an example
xL <- split(x, rep(letters[1:5], c(6,7,5,4,4)));
xL;

# now run mixedSorts(xL)
# Notice "e5" is sorted before "e28"
mixedSorts(xL)

# for fun, compare to lapply(xL, sort)
# Notice "e5" is sorted after "e28"
lapply(xL, sort)

# Make a nested list
set.seed(1);
l1 <- list(
   A=sample(nameVector(11:13, rev(letters[11:13]))),
   B=list(
      C=sample(nameVector(4:8, rev(LETTERS[4:8]))),
      D=sample(nameVector(LETTERS[2:5], rev(LETTERS[2:5])))
   )
)
l1;
# The output is a nested list with the same structure
mixedSorts(l1);
mixedSorts(l1, sortByName=TRUE);

# when one entry is missing
L0 <- list(A=3:1,
   B=list(C=c(1:3,NA,0),
   D=LETTERS[c(4,5,2)],
   E=NULL));
L0
mixedSorts(L0)
mixedSorts(L0, na.rm=TRUE)

}
\seealso{
Other jam sort functions: 
\code{\link{mixedOrder}()},
\code{\link{mixedSortDF}()},
\code{\link{mixedSort}()},
\code{\link{mmixedOrder}()}

Other jam string functions: 
\code{\link{asSize}()},
\code{\link{breaksByVector}()},
\code{\link{cPasteSU}()},
\code{\link{cPasteS}()},
\code{\link{cPasteUnique}()},
\code{\link{cPasteU}()},
\code{\link{cPaste}()},
\code{\link{fillBlanks}()},
\code{\link{formatInt}()},
\code{\link{gsubOrdered}()},
\code{\link{makeNames}()},
\code{\link{mixedOrder}()},
\code{\link{mixedSortDF}()},
\code{\link{mixedSort}()},
\code{\link{mmixedOrder}()},
\code{\link{nameVectorN}()},
\code{\link{nameVector}()},
\code{\link{padInteger}()},
\code{\link{padString}()},
\code{\link{pasteByRowOrdered}()},
\code{\link{pasteByRow}()},
\code{\link{tcount2}()},
\code{\link{tcount}()},
\code{\link{ucfirst}()},
\code{\link{uniques}()}

Other jam list functions: 
\code{\link{cPasteSU}()},
\code{\link{cPasteS}()},
\code{\link{cPasteUnique}()},
\code{\link{cPasteU}()},
\code{\link{cPaste}()},
\code{\link{jam_rapply}()},
\code{\link{list2df}()},
\code{\link{mergeAllXY}()},
\code{\link{rbindList}()},
\code{\link{relist_named}()},
\code{\link{rlengths}()},
\code{\link{sclass}()},
\code{\link{sdima}()},
\code{\link{sdim}()},
\code{\link{ssdima}()},
\code{\link{ssdim}()},
\code{\link{uniques}()},
\code{\link{unnestList}()}
}
\concept{jam list functions}
\concept{jam sort functions}
\concept{jam string functions}
