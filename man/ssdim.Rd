% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamba.r
\name{ssdim}
\alias{ssdim}
\title{print dimensions of nested list objects}
\usage{
ssdim(x, includeClass = TRUE, doFormat = FALSE, big.mark = ",",
  verbose = FALSE, ...)
}
\arguments{
\item{x}{an S3 object inheriting from class "list", typically a list of
lists, but will accept a list object in which case it simply calls
\code{sdim(x)} once, in order to avoid treating a data.frame as a list.}

\item{includeClass}{boolean passed to \code{sdim()},
indicating whether to print the class of
each element in the input \code{x} object. Note that for S4 objects,
each element will be the object returned for each of \code{slotNames(x)}.}

\item{doFormat}{boolean passed to \code{sdim()},
indicating whether to format the dimensions using
\code{format(...,big.mark=",")}, which is mainly useful for extremely
large dimensions. This parameter should probably become more broadly
useful and respectful for different locales.}

\item{big.mark}{character passed to \code{sdim()},
value used when \code{doFormat=TRUE}, used in the
call to \code{format(...,big.mark)}.}

\item{verbose}{logical whether to print verbose output}

\item{...}{additional parameters are ignored.}
}
\value{
\code{list} of \code{data.frame}, each row indicates the dimensions of
each element in the input list. When \code{includeClass} is \code{TRUE} it
will include a column \code{class} which indicates the class of each
list element. When the input list contains arrays with more than
two dimensions, the first two dimensions are named \code{"rows"} and
\code{"columns"} with additional dimensions named \code{"dim3"} and so on.
Any list element with fewer than that many dimensions will only have
values populated to the relevant dimensions, for example a character
vector will only populate the length.
}
\description{
print dimensions of list nested objects, such as a list of lists
}
\details{
This function iteratively calls \code{sdim(x)} on each list element,
which can be helpful for some more complicated object formats. In future,
the intent is to recurse through a nested list structure, but currently
this process only recurses two steps. Attempts to recurse deeper sometimes
results in printing much more detail than originally intended.
}
\examples{
L <- list(LETTERS=LETTERS,
   letters=letters,
   lettersDF=data.frame(LETTERS, letters));
L2 <- list(List1=L,
   List2=L);

sdim(L);
ssdim(L2);

}
\seealso{
Other jam practical functions: \code{\link{applyCLrange}},
  \code{\link{breakDensity}}, \code{\link{checkLightMode}},
  \code{\link{colNum2excelName}}, \code{\link{fileInfo}},
  \code{\link{fixYellowHue}}, \code{\link{fixYellow}},
  \code{\link{getAxisLabel}}, \code{\link{handleArgsText}},
  \code{\link{isFALSEV}}, \code{\link{isTRUEV}},
  \code{\link{jamba}}, \code{\link{jargs}},
  \code{\link{kable_coloring}}, \code{\link{log2signed}},
  \code{\link{make_styles}}, \code{\link{mergeAllXY}},
  \code{\link{minorLogTicks}}, \code{\link{newestFile}},
  \code{\link{printDebug}}, \code{\link{renameColumn}},
  \code{\link{rmInfinite}}, \code{\link{rmNA}},
  \code{\link{rmNULL}}, \code{\link{sclass}},
  \code{\link{sdim}}, \code{\link{setCLranges}},
  \code{\link{setPrompt}}

Other jam list functions: \code{\link{cPasteSU}},
  \code{\link{cPasteS}}, \code{\link{cPasteUnique}},
  \code{\link{cPasteU}}, \code{\link{cPaste}},
  \code{\link{list2df}}, \code{\link{mergeAllXY}},
  \code{\link{mixedSorts}}, \code{\link{rbindList}},
  \code{\link{relist_named}}, \code{\link{rlengths}},
  \code{\link{sclass}}, \code{\link{sdim}},
  \code{\link{uniques}}, \code{\link{unnestList}}
}
\concept{jam list functions}
\concept{jam practical functions}
